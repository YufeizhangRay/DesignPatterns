# DesignPatterns
设计模式  
  
学习收集的几种设计模式：  
1.适配器模式  
>>适配器模式核心思想就是保证`兼容性`。  
老系统运行了很久比较稳定，为了保证其稳定性，不再修改原来的代码，但是为了兼容新的需求和标准，我们需要做一些改进。当项目的功能进行升级改进的时候，开发者可以在不修改老代码的情况下加入的新的方法，使得新的功能可以与之前的功能兼容。例如早年间大多是通过先注册，再使用账号密码对某些应用进行登录的方式，而现在出现了可以直接用微信或者QQ一键登录应用的方式。完成这种任务就可以采用适配器模式，不改变之前的代码，直接以其为基础进行二次开发。 详情请见代码。
  
2.装饰器模式  
>>装饰器模式的核心思想是功能的增强。  
装饰器模式和适配器模式有一定的相似性，它可以为某个实现类在不修改原始类的基础上进行动态的覆盖或者方法的增强，实际上一种特殊的适配器模式。同样是以上面的登录方式为例，适配器模式可以以旧方法为基础进行二次开发，而装饰器模式则可以直接写出新的代码，增加新的方法。使老系统的功能更多更强。详情请见代码。 
  
>>两种设计模式对比：  
            ------------------------------------------------------------------------------------   
            装饰器模式  　　　　　　　　　　　　　|   适配器模式  
            -----------------------------------------------------------------------------------   
            是一种非常特别的适配器模式          　 　　　　|  可以不保留层级关系  
            ------------------------------------------------------------------------------------   
            装饰者和被装饰者都要实现同一个接口    　 |  适配者和被适配者没有必然的层级联系  
            主要目的是为了扩展，依旧保留OOP关系    |  通常采用代理或者继承形式进行包装  
            ------------------------------------------------------------------------------------   
            满足is-a的关系                 　　　　　　　　　　　 |   满足has-a  
            ------------------------------------------------------------------------------------   
            注重的是覆盖、扩展             　　　　　　　　　 |   注重兼容、转换  
            -----------------------------------------------------------------------------------   

3.委派模式  
>>委派模式核心思想是分发、调度、派遣。  
委派模式中有有三个角色，可以具体化为老板、项目经理和普通员工。老板可以下发一个任务给项目经理(这里有点类似于代理模式)，项目经理在根据权衡之后会将任务委派给最适合的普通员工完成(这里类似于策略模式)。委派模式是一种全权代理，注重的是结果。在老板眼里，项目经理负责干活，而实际上项目经理只是发挥了调度的作用。详情请见代码。  
  
4.抽象工厂模式  
>>工厂模式分为简单工厂与抽象工厂等，这里收录的是抽象工程模式，这也是Spring中使用的最广泛的一种设计模式。抽象工厂模式主要解决接口选择的问题，可以在同一个工厂类里聚合多个同类接口，为发开者直接提供选择，大大简化了开发的操作难度。详情请见代码。  
  
5.观察者模式  
>>观察者模式中存在两种角色，观察者与被观察者。当被观察者做出不同的动作时，观察者都会立刻察觉，最直接的实现就是监听器。观察者模式类似于订阅但是又有所不同。在观察者模式中，观察者要“主动“的去“观察”被观察者。而订阅中的订阅者不需要”主动“去盯着被订阅者，当被订阅者发出消息后，订阅者可以被动获取此消息，消息中间ActiveMQ拥有这样的功能。详情请见代码。  
  
6.代理模式  
>>代理模式的作用是专人做专事，被代理者可以将自己不擅长或者没有时间去做的事情交给更专业代理者去完成。  
例如年轻人找对象这件事，许多年轻人可能忙于工作没有时间，此时就可以让爸妈去帮忙，或者直接去专业的中介去做委托。让爸妈帮忙的方式是一种静态的代理模式，因为爸妈只能帮助自己找，而不会帮助其他陌生人(在代理之前，所有东西都是已知的)。表现在代码中则是在编译之前就已经定义好的对象，无法在程序运行时做出更改。而交给专业中介的方式则类似于动态代理，专业机构可以给任何去进行服务，而不值局限于某个人(在代理之前，所有东西都是未知的)。表现在代码中就是没有定义准确的对象，可以在程序运行的时候动态生成代理对象，灵活性更强。Spring的AOP功能就是利用动态代理实现的。这里分别收录了静态代理与动态代理，详情请见代码。  
  
7.单例模式  
>>单例模式就如其字面意思，目的是为了保证对象在整个生命周期中是全局唯一的。  
Spring中对Bean管理默认采用单例模式，其实现原理是利用HashMap完成了注册式单例。除了注册式单例外，还有饿汉式单例与懒汉式单例。实现单例模式的基本保障就是构造函数的私有化，从而让其他需要单例对象的方法不能直接通过构造方法获得对象，而是要通过调用访问类型为public的static方法getInstance()来获取已经存在的对象。  
饿汉式单例的实现原理是类在加载的时候回首先初始化静态域，于是可以将类的对象声明为静态的类实例对象，并且在代码中直接将其初始化，保证在其他方法需要次对象的时候它一定存在。但是缺点也很明显，没有方法需要用到次对象，它的产生就相当于浪费了内存空间。  
懒汉式单例则相反，对象不会在一开始就被实例化出来，而是有方法需要的手再进行创建。这样就可以避免可能存在的内存空间的浪费，但是同时也会造成线程安全问题。当两个线程同时需要对象，并且均判断对象为null时，两个线程会对对象初始化两次。为了解决这个问题，我们可以用synchronized关键字来解决，但是同时synchronized关键字会造成程序性能的下降，具体原因我在这里有解释[霍夫曼文件压缩程序](https://github.com/YufeizhangRay/Hoffman-file-compression-program/blob/master/README.md)。于是还有另一种方法来解决synchronized关键字降低效率的问题，那就是使用内部类，详情请见代码。   
  
8.策略模式  
>>策略模式在程序的整体运行上有一套不固定的过程，但是拥有同样的开始，同样的结果，唯一可以体现策略二字的就是可以给用户选择得到结果之前的中间实现过程。  
例如我们在进行网购的时候，我们所要经历的流程是固定的，选择商品，购物车，下单，结算，支付，物流。其中支付这一过程我们可以进行选择使用支付宝或者微信等等。再例如人们出去旅行，可以选择不同的交通工具，最后到达的目的地都是一样的。详情请见代码。  
  
9.模板模式
>>模板模式同样拥有一套固定的过程，但是不一定有同样的开始和同样的结果，而且模板模式中每一个中间实现过程都没有可以进行替代的选择。  
例如饮料加工，过程可以分为加原料，加水，加工等。我们必须严格按照此步骤进行，但是我们可以在开始的时候放入不同的原料，最后得到的也是不同的果汁。
